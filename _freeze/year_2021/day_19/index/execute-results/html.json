{
  "hash": "9b9c704a0876130ca132692bd1be0ff1",
  "result": {
    "markdown": "---\ntitle: \"2021 - Day 19\"\nformat:\n  html:\n    code-fold: show\n    code-tools: true\n    code-block-bg: true\n    code-block-border-left: \"#AB63BD\"\n---\n\n\n## Set-Up\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- readLines(\"input.txt\")\nstr(input)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:1105] \"--- scanner 0 ---\" \"645,-448,-766\" \"529,751,-867\" ...\n```\n:::\n\n```{.r .cell-code}\ngaps <- c(0, which(input == \"\"))\norientations <- expand.grid(x = c(1, -1), y = c(1, -1), z = c(1, -1))\nscanners <- lapply(seq_along(gaps), \\(x) {\n  if (x == length(gaps)) nrows <- -1 else nrows <- gaps[x + 1] - gaps[x] - 2\n  beacons <- read.csv(\n    \"input.txt\", header = FALSE, skip = gaps[x] + 1, nrows = nrows,\n    col.names = c(\"x\", \"y\", \"z\")\n  )\n  beacons <- as.matrix(beacons)\n\n  # Everything said 24 directions, have mirrors here (so does make solution slower)\n  all_locations <- c(\n    apply(orientations, 1, \\(y) t(y * t(beacons)), simplify = FALSE),\n    apply(orientations, 1, \\(y) t(y * t(beacons[, c(\"x\", \"z\", \"y\")])), simplify = FALSE),\n    apply(orientations, 1, \\(y) t(y * t(beacons[, c(\"y\", \"x\", \"z\")])), simplify = FALSE),\n    apply(orientations, 1, \\(y) t(y * t(beacons[, c(\"y\", \"z\", \"x\")])), simplify = FALSE),\n    apply(orientations, 1, \\(y) t(y * t(beacons[, c(\"z\", \"x\", \"y\")])), simplify = FALSE),\n    apply(orientations, 1, \\(y) t(y * t(beacons[, c(\"z\", \"y\", \"x\")])), simplify = FALSE)\n  )\n\n  # Column rename for consistency\n  lapply(all_locations, \\(y) {colnames(y) <- c(\"x\", \"y\", \"z\"); y})\n})\n```\n:::\n\n\n## Part 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Scanner 1 is source of truth\nbeacon_locations <- scanners[[1]][[1]]\nto_scan <- seq(2, length(scanners))\nscanner_locations <- c(0, 0, 0)\n\nwhile (length(to_scan) > 0) {\n  for (i in to_scan) {\n    k <- length(scanners[[i]])\n    # Run through all combinations to look for connecting points\n    for (j in seq_along(scanners[[i]])) {\n      # Gets the x,y,z distances of each beacon to the known locations. Pasting together for speed\n      distances <- apply(scanners[[i]][[j]], 1, \\(x) {\n        m <- sweep(beacon_locations, 2, x)\n        paste(m[, 1], m[, 2], m[, 3])\n      })\n      distances_comb <- table(as.vector(distances))\n      if (any(distances_comb >= 12)) break\n    }\n\n    # If no overlap leave to be scanned again\n    if (j == length(scanners[[i]]) && !any(distances_comb >= 12)) next\n    to_scan <- setdiff(to_scan, i)\n\n    # Find the locations of the scanner and new beacons\n    translation <- as.numeric(strsplit(names(distances_comb[distances_comb >= 12]), \" \")[[1]])\n    scanner_locations <- rbind(scanner_locations, translation)\n    beacon_locations2 <- rbind(beacon_locations, sweep(scanners[[i]][[j]], 2, translation, \"+\"))\n    beacon_locations <- beacon_locations2[!duplicated(beacon_locations2), ]\n  }\n}\n\nnrow(beacon_locations)\n```\n:::\n\n\n## Part 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmax(apply(scanner_locations, 1, \\(x) max(rowSums(abs(sweep(scanner_locations, 2, x))))))\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}