{
  "hash": "6899709140be2319697d1813938b80de",
  "result": {
    "markdown": "---\nformat:\n  html:\n    code-fold: show\n    code-tools: true\n    code-block-bg: true\n    code-block-border-left: \"#AB63BD\"\n---\n\n\n## Set-Up\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstructions <- readLines(\"input.txt\")\nstr(instructions)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:420] \"on x=-17..30,y=-5..41,z=-33..14\" ...\n```\n:::\n\n```{.r .cell-code}\ninst <- as.data.frame(do.call(rbind, regmatches(instructions, gregexpr(\"on|off|(-|)\\\\d+\", instructions))))\nnames(inst) <- c(\"switch\", \"x1\", \"x2\", \"y1\", \"y2\", \"z1\", \"z2\")\ninst[, -1] <- sapply(inst[, -1], as.numeric)\ninst[, -1] <- cbind(\n  x1 = pmin(inst$x1, inst$x2), x2 = pmax(inst$x1, inst$x2),\n  y1 = pmin(inst$y1, inst$y2), y2 = pmax(inst$y1, inst$y2),\n  z1 = pmin(inst$z1, inst$z2), z2 = pmax(inst$z1, inst$z2)\n)\n```\n:::\n\n\n## Part 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmini_inst <- inst\nmini_inst[, -1] <- mini_inst[, -1] + 51\nmini_board <- which(rowMeans(mini_inst[, -1] >= 1 & mini_inst[, -1] <= 101) == 1)\nswitches <- array(0, c(101, 101, 101))\n\nfor (i in mini_board) {\n  value <- as.numeric(mini_inst$switch[i] == \"on\")\n  switches[\n    seq(mini_inst$x1[i], mini_inst$x2[i]),\n    seq(mini_inst$y1[i], mini_inst$y2[i]),\n    seq(mini_inst$z1[i], mini_inst$z2[i])\n  ] <- value\n}\nsum(switches)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 600458\n```\n:::\n:::\n\n\n## Part 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- sort(unique(c(inst$x1, inst$x2 + 1)))\ny <- sort(unique(c(inst$y1, inst$y2 + 1)))\nz <- sort(unique(c(inst$z1, inst$z2 + 1)))\nlocs <- array(0, lengths(list(x, y, z)))\n\nfor (i in seq(nrow(inst))) {\n  x_range <- seq(which(inst$x1[i] == x), which(inst$x2[i] + 1 == x) - 1)\n  y_range <- seq(which(inst$y1[i] == y), which(inst$y2[i] + 1 == y) - 1)\n  z_range <- seq(which(inst$z1[i] == z), which(inst$z2[i] + 1 == z) - 1)\n  locs[as.matrix(expand.grid(x_range, y_range, z_range))] <- as.numeric(inst$switch[i] == \"on\")\n}\n\non_points <- which(locs == 1, arr.ind = TRUE)\non_points2 <- on_points + 1\n\nsum(\n  (x[on_points2[, 1]] - x[on_points[, 1]]) *\n    (y[on_points2[, 2]] - y[on_points[, 2]]) *\n    (z[on_points2[, 3]] - z[on_points[, 3]])\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.334275e+15\n```\n:::\n:::\n\n\n## Part 2 - Attempt 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfindNCubes <- function(x) sum(apply(abs(x[, c(\"x2\", \"y2\", \"z2\")] - x[, c(\"x1\", \"y1\", \"z1\")]) + 1, 1, prod))\n# c1 Current cube, c2 previous cube\nexcludeOverlap <- function(c1, c2) {\n  # No Overlap\n  if (any(c1[, c(\"x1\", \"y1\", \"z1\")] > c2[, c(\"x2\", \"y2\", \"z2\")]) |\n      any(c1[, c(\"x2\", \"y2\", \"z2\")] < c2[, c(\"x1\", \"y1\", \"z1\")])) {\n    c1\n  # Full Outer Overlap\n  } else if (all(c1[, c(\"x1\", \"y1\", \"z1\")] >= c2[, c(\"x1\", \"y1\", \"z1\")] &\n                 c1[, c(\"x2\", \"y2\", \"z2\")] <= c2[, c(\"x2\", \"y2\", \"z2\")])) {\n    NULL\n    # Partial Outer Overlap\n  } else {\n    x_extra <- y_extra <- z_extra <- NULL\n    x1 <- c1$x1\n    x2 <- c1$x2\n    y1 <- c1$y1\n    y2 <- c1$y2\n    z1 <- c1$z1\n    z2 <- c1$z2\n\n    if (c1$x1 < c2$x1 && c1$x2 > c2$x2) {\n      x_extra <- data.frame(x1 = c(x1, c2$x2 + 1), x2 = c(c2$x1, x2 + 1), y1 = y1, y2 = y2, z1 = z1, z2 = z2)\n      x1 <- c2$x1\n      x2 <- c2$x2\n    }\n    if (c1$y1 < c2$y1 && c1$y2 > c2$y2) {\n      y_extra <- data.frame(x1 = x1, x2 = x2, y1 = c(y1, c2$y2 + 1), y2 = c(c2$y1, y2 + 1), z1 = z1, z2 = z2)\n      y1 <- c2$y1\n      y2 <- c2$y2\n    }\n    if (c1$z1 < c2$z1 && c1$z2 > c2$z2) {\n      z_extra <- data.frame(x1 = x1, x2 = x2, y1 = y1, y2 = y2, z1 = c(c1$z1, c2$z2 + 1), z2 = c(c2$z1 - 1, c1$z2))\n      z1 <- c2$z1\n      z2 <- c2$z2\n    }\n\n    # Partial Inner Overlap\n    x_min <- max(x1, c2$x1)\n    x_max <- min(x2, c2$x2)\n    y_min <- max(y1, c2$y1)\n    y_max <- min(y2, c2$y2)\n\n    rbind(\n      if (x1 >= c2$x1 && x2 > c2$x2) data.frame(x1 = c2$x2 + 1, x2 = x2, y1 = y1, y2 = y2, z1 = z1, z2 = z2),\n      if (y1 >= c2$y1 && y2 > c2$y2) data.frame(x1 = x_min, x2 = x_max, y1 = c2$y2 + 1, y2 = y2, z1 = z1, z2 = z2),\n      if (z1 >= c2$z1 && z2 > c2$z2) data.frame(x1 = x_min, x2 = x_max, y1 = y_min, y2 = y_max, z1 = c2$z2 + 1, z2 = z2),\n      if (x2 <= c2$x2 && x1 < c2$x1) data.frame(x1 = x1, x2 = c2$x1 - 1, y1 = y1, y2 = y2, z1 = z1, z2 = z2),\n      if (y2 <= c2$y2 && y1 < c2$y1) data.frame(x1 = x_min, x2 = x_max, y1 = y1, y2 = c2$y1 - 1, z1 = z1, z2 = z2),\n      if (z2 <= c2$z2 && z1 < c2$z1) data.frame(x1 = x_min, x2 = x_max, y1 = y_min, y2 = y_max, z1 = z1, z2 = c2$z1 - 1),\n      x_extra,\n      y_extra,\n      z_extra\n    )\n  }\n}\n\non_cubes <- inst[1, -1]\nfor (i in seq(2, nrow(inst))) {\n  print(i)\n  curr_cube <- inst[i, -1]\n\n  if (inst$switch[i] == \"on\") {\n\n    for (j in seq(nrow(on_cubes))) {\n      new_spaces <- NULL\n      for (k in seq(nrow(curr_cube))) {\n        new_spaces <- rbind(new_spaces, excludeOverlap(curr_cube[k, ], on_cubes[j, ]))\n      }\n      curr_cube <- new_spaces\n      if (is.null(curr_cube)) {\n        break\n      }\n    }\n    on_cubes <- rbind(on_cubes, curr_cube)\n\n  } else {\n    new_spaces <- NULL\n    for (j in seq(nrow(on_cubes))) {\n      new_spaces <- rbind(new_spaces, excludeOverlap(c1 = on_cubes[j, ], c2 = inst[i, ]))\n    }\n    on_cubes <- new_spaces\n  }\n}\n\nsum(switches)\nfindNCubes(on_cubes)\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}